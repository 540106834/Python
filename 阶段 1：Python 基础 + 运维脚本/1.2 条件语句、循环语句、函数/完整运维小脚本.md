太好了 😄
下面我帮你写一个 **阶段 1 的完整运维小脚本**，把我们前面学的 **条件判断 + 循环 + 函数 + 日志 + 模拟指标** 全部结合起来，让你边学边实践。

---

# 🐍 阶段 1 实战脚本：多服务 CPU/Memory 模拟监控

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging
import random
from datetime import datetime

# -----------------------
# 日志配置
# -----------------------
logging.basicConfig(
    filename="monitor.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

# -----------------------
# 函数：检查 CPU
# -----------------------
def check_cpu(cpu):
    """根据 CPU 使用率返回告警等级"""
    if cpu > 90:
        return "🚨 CPU 高级告警"
    elif cpu > 80:
        return "⚠️ CPU 普通告警"
    else:
        return "✅ CPU 正常"

# -----------------------
# 函数：检查内存
# -----------------------
def check_memory(memory):
    """根据内存使用率返回告警等级"""
    if memory > 90:
        return "🚨 内存高级告警"
    elif memory > 80:
        return "⚠️ 内存普通告警"
    else:
        return "✅ 内存正常"

# -----------------------
# 函数：检查服务状态
# -----------------------
def check_service(service, cpu, memory):
    """检查服务 CPU 和内存，并写入日志"""
    cpu_result = check_cpu(cpu)
    mem_result = check_memory(memory)

    log_msg = f"{service}: CPU={cpu}%, Memory={memory}% | {cpu_result} | {mem_result}"
    logging.info(log_msg)
    print(log_msg)

# -----------------------
# 主程序
# -----------------------
def main():
    # 模拟服务列表
    services = ["auth", "payment", "monitoring"]

    # 循环遍历每个服务
    for svc in services:
        # 模拟 CPU / Memory 使用率 (50-100)
        cpu_usage = random.randint(50, 100)
        memory_usage = random.randint(50, 100)

        # 检查服务状态
        check_service(svc, cpu_usage, memory_usage)

    # 模拟 while 循环倒计时示例
    countdown = 5
    while countdown > 0:
        print(f"下次监控倒计时: {countdown} 秒")
        countdown -= 1

if __name__ == "__main__":
    main()
```

---

## ✅ 脚本亮点

1. **条件判断**：根据 CPU/Memory 使用率输出多级告警
2. **循环**：遍历服务列表，同时演示 while 倒计时
3. **函数封装**：`check_cpu`, `check_memory`, `check_service`
4. **日志记录**：每次运行都会写入 `monitor.log`
5. **模拟指标**：随机生成 CPU/Memory 数值，便于练习

---

## 🔧 运行示例

```bash
python monitor_stage1.py
```

**控制台输出示例**

```
auth: CPU=85%, Memory=72% | ⚠️ CPU 普通告警 | ✅ 内存正常
payment: CPU=92%, Memory=88% | 🚨 CPU 高级告警 | ⚠️ 内存普通告警
monitoring: CPU=65%, Memory=95% | ✅ CPU 正常 | 🚨 内存高级告警
下次监控倒计时: 5 秒
下次监控倒计时: 4 秒
...
```

**日志文件 monitor.log**

```
2025-10-26 09:49:23,456 - INFO - auth: CPU=85%, Memory=72% | ⚠️ CPU 普通告警 | ✅ 内存正常
2025-10-26 09:49:23,457 - INFO - payment: CPU=92%, Memory=88% | 🚨 CPU 高级告警 | ⚠️ 内存普通告警
2025-10-26 09:49:23,457 - INFO - monitoring: CPU=65%, Memory=95% | ✅ CPU 正常 | 🚨 内存高级告警
```

---

如果你愿意，我可以帮你把 **这个脚本升级到阶段 2**：
加入 **YAML 配置 + 命令行参数覆盖阈值 + 异常处理**，更接近 SRE 监控实战脚本。

你希望我帮你升级吗？


明白了，我帮你把之前的完整运维小脚本升级为 **支持 YAML 配置 + 命令行参数覆盖阈值 + 异常保护** 的版本，同时保留 CPU/内存/磁盘检查、日志轮转、HTTP 请求等功能。

---

# **完整运维脚本（带 YAML 配置 + CLI 参数 + 异常处理）**

```python
import os
import shutil
import time
import psutil
import requests
import yaml
import argparse
import sys

# --------------------------
# 函数定义
# --------------------------

def load_config(yaml_file):
    """加载 YAML 配置"""
    try:
        with open(yaml_file, "r") as f:
            config = yaml.safe_load(f)
        return config
    except FileNotFoundError:
        print(f"配置文件 {yaml_file} 未找到，使用默认配置")
        return {}
    except yaml.YAMLError as e:
        print(f"YAML 解析错误: {e}")
        return {}

def check_cpu(threshold):
    try:
        cpu = psutil.cpu_percent(interval=1)
        if cpu < threshold * 0.6:
            status = "正常"
        elif cpu < threshold:
            status = "偏高"
        else:
            status = "过高"
        return cpu, status
    except Exception as e:
        print(f"检查 CPU 出错: {e}")
        return None, "未知"

def check_memory(threshold):
    try:
        mem = psutil.virtual_memory().percent
        if mem < threshold * 0.6:
            status = "正常"
        elif mem < threshold:
            status = "偏高"
        else:
            status = "过高"
        return mem, status
    except Exception as e:
        print(f"检查内存出错: {e}")
        return None, "未知"

def check_disks(threshold):
    alerts = []
    try:
        for part in psutil.disk_partitions():
            usage = psutil.disk_usage(part.mountpoint).percent
            if usage > threshold:
                alerts.append(f"{part.mountpoint} 使用率 {usage}% 超过阈值")
    except Exception as e:
        alerts.append(f"磁盘检查出错: {e}")
    return alerts

def rotate_logs(log_dir, max_files=5):
    try:
        archive_dir = os.path.join(log_dir, "archive")
        os.makedirs(archive_dir, exist_ok=True)
        
        logs = sorted([f for f in os.listdir(log_dir) if f.endswith(".log")])
        while len(logs) > max_files:
            oldest = logs.pop(0)
            shutil.move(os.path.join(log_dir, oldest), os.path.join(archive_dir, oldest))
            print(f"已归档日志: {oldest}")
    except Exception as e:
        print(f"日志轮转出错: {e}")

def fetch_url(url, retries=3):
    for attempt in range(1, retries+1):
        try:
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            return response.text
        except requests.RequestException as e:
            print(f"第 {attempt} 次请求失败: {e}")
            time.sleep(1)
    return None

# --------------------------
# 主流程
# --------------------------

def main():
    # ----------------------
    # 命令行参数解析
    # ----------------------
    parser = argparse.ArgumentParser(description="运维监控脚本")
    parser.add_argument("--config", default="config.yaml", help="YAML 配置文件路径")
    parser.add_argument("--cpu", type=int, help="CPU 告警阈值")
    parser.add_argument("--mem", type=int, help="内存告警阈值")
    parser.add_argument("--disk", type=int, help="磁盘告警阈值")
    args = parser.parse_args()

    # ----------------------
    # 加载 YAML 配置
    # ----------------------
    config = load_config(args.config)
    cpu_threshold = args.cpu or config.get("cpu_threshold", 80)
    mem_threshold = args.mem or config.get("mem_threshold", 70)
    disk_threshold = args.disk or config.get("disk_threshold", 80)
    log_dir = config.get("log_dir", "./logs")
    max_log_files = config.get("max_log_files", 5)
    url = config.get("url", "http://example.com/api/health")
    retries = config.get("http_retries", 3)

    # ----------------------
    # 系统资源检查
    # ----------------------
    print("=== 系统资源检查 ===")
    cpu_val, cpu_status = check_cpu(cpu_threshold)
    print(f"CPU 使用率: {cpu_val}% 状态: {cpu_status}")

    mem_val, mem_status = check_memory(mem_threshold)
    print(f"内存使用率: {mem_val}% 状态: {mem_status}")

    disk_alerts = check_disks(disk_threshold)
    if disk_alerts:
        for alert in disk_alerts:
            print(alert)
    else:
        print("磁盘使用正常")

    # ----------------------
    # 日志轮转
    # ----------------------
    print("\n=== 日志轮转 ===")
    rotate_logs(log_dir, max_files)

    # ----------------------
    # HTTP 请求检测
    # ----------------------
    print("\n=== HTTP 请求检测 ===")
    result = fetch_url(url, retries)
    if result:
        print("HTTP 请求成功")
    else:
        print("HTTP 请求失败")

# --------------------------
# 执行脚本
# --------------------------

if __name__ == "__main__":
    main()
```

---

# **YAML 配置示例 (`config.yaml`)**

```yaml
cpu_threshold: 75
mem_threshold: 70
disk_threshold: 80
log_dir: ./logs
max_log_files: 5
url: http://example.com/api/health
http_retries: 3
```

---

# **脚本说明**

1. **YAML 配置**

   * 支持 CPU/内存/磁盘阈值、日志目录、HTTP URL 等参数
   * `load_config` 函数读取配置文件

2. **命令行参数覆盖**

   * `--cpu`, `--mem`, `--disk` 可覆盖 YAML 中阈值
   * 使用 `argparse` 实现

3. **异常保护**

   * 每个函数都加 `try/except` 捕获异常
   * 避免单点失败导致脚本中断

4. **功能覆盖**

   * CPU/内存/磁盘告警检查
   * 日志轮转
   * HTTP 请求重试

5. **扩展性**

   * 可批量监控多台服务器
   * 可结合定时任务(cron)实现定期执行

---

如果你愿意，我可以帮你 **画一张脚本执行流程图**，可视化 **配置加载 → 阈值解析 → 资源检查 → 日志轮转 → HTTP 检测 → 异常处理** 的流程，让整个逻辑更清晰。

你希望我画吗？
